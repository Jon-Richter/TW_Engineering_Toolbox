
"""
Wood Formwork Design (Dash)
- Fresh concrete lateral pressure per ACI 347R-14 (inch-pound)
- ASD-style member utilization checks for plywood, studs, double walers, ties
- Wall height segmentation with non-uniform pressure profile and member-by-elevation critical checks
- NDS presets (species/grade + adjustment factors) for dimension lumber used as studs/walers
- Edge/corner tie tributary-area reductions vs interior ties
- Exportable CSV / PDF calculation report

Engineering notes:
- Load path is idealized 1-way with simply supported members.
- Pressure profile assumed p(z)=min(w*z, p_cap) where z is depth from the top of placement.
- Walers are checked using a conservative uniform line-load approximation based on local tributary band.
- Connection design, bearing/crushing, combined bending+axial, and stability are not included.

Author: Generated by ChatGPT
"""
from __future__ import annotations

import sys

try:
    import numpy as np
    import pandas as pd
    from dash import Dash, dcc, html, dash_table
    from dash.dependencies import Input, Output, State
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.styles import getSampleStyleSheet
except Exception as e:
    sys.exit(
        "Required Python packages are missing or failed to import.\n"
        f"Python executable: {sys.executable}\n"
        f"Error: {e}\n"
        "Install with:\n"
        f"{sys.executable} -m pip install -r requirements.txt"
    )

import io
import json
import math
import os
import datetime as dt
import threading, time
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional


# -----------------------------
# Helpers / unit conversions
# -----------------------------
def in_to_ft(x_in: float) -> float:
    return float(x_in) / 12.0

def ft_to_in(x_ft: float) -> float:
    return float(x_ft) * 12.0

def safe_float(x, default=float("nan")) -> float:
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default


# -----------------------------
# Section properties (nominal dimensions)
# -----------------------------
# Nominal dimension lumber (in)
DIMLUMBER_DB = {
    "2x4":  (1.5, 3.5),
    "2x6":  (1.5, 5.5),
    "2x8":  (1.5, 7.25),
    "2x10": (1.5, 9.25),
    "2x12": (1.5, 11.25),
    "4x4":  (3.5, 3.5),
    "4x6":  (3.5, 5.5),
    "4x8":  (3.5, 7.25),
}

DIMLUMBER_OPTIONS = ["2x4","2x6","2x8","2x10","2x12","4x4","4x6"]

def rect_I(b_in: float, d_in: float) -> float:
    return b_in * d_in**3 / 12.0

def rect_S(b_in: float, d_in: float) -> float:
    return b_in * d_in**2 / 6.0

def rect_A(b_in: float, d_in: float) -> float:
    return b_in * d_in

def member_props_dimlumber(size: str, strong_axis: bool = True) -> Tuple[float, float, float]:
    """
    Returns (S, I, A) in in^3, in^4, in^2.
    strong_axis=True: bending about strong axis (depth = larger dim)
    """
    if size not in DIMLUMBER_DB:
        raise ValueError(f"Unknown size: {size}")
    b, d = DIMLUMBER_DB[size]
    if not strong_axis and d > b:
        b, d = d, b
    S = rect_S(b, d)
    I = rect_I(b, d)
    A = rect_A(b, d)
    return S, I, A


def member_props_plywood_strip(t_in: float, strip_width_in: float = 12.0) -> Tuple[float, float, float]:
    """
    1-ft wide strip by default.
    Returns (S, I, A) in in^3, in^4, in^2.
    """
    b = float(strip_width_in)
    t = float(t_in)
    S = b * t**2 / 6.0
    I = b * t**3 / 12.0
    A = b * t
    return S, I, A


# -----------------------------
# Simple beam analysis (numeric) for arbitrary distributed load
# -----------------------------
@dataclass
class BeamResult:
    Mmax_lbft: float
    Vmax_lb: float
    defl_max_in: float

def beam_simply_supported_distributed(
    L_ft: float,
    w_func_lbft: np.ndarray,
    x_ft: np.ndarray,
    E_psi: float,
    I_in4: float,
) -> BeamResult:
    """
    Numeric solution:
    - reactions from statics
    - shear/moment from integration
    - deflection from curvature integration: y'' = M / (E I)
    Inputs:
      w_func_lbft : load intensity sampled at x_ft points (lb/ft)
      x_ft        : coordinates (ft), same length as w_func_lbft, monotonic
      E_psi, I_in4 for deflection
    """
    L_ft = float(L_ft)
    if L_ft <= 0 or len(x_ft) < 3:
        return BeamResult(float("nan"), float("nan"), float("nan"))

    # Total load and moment about left
    W = np.trapezoid(w_func_lbft, x_ft)  # lb
    M_about_left = np.trapezoid(w_func_lbft * x_ft, x_ft)  # lb-ft

    R2 = M_about_left / L_ft if L_ft > 0 else float("nan")
    R1 = W - R2

    # Shear V(x) = R1 - integral_0^x w dx
    w_int = np.cumsum((w_func_lbft[:-1] + w_func_lbft[1:]) * 0.5 * np.diff(x_ft))
    w_int = np.concatenate([[0.0], w_int])
    V = R1 - w_int

    # Moment M(x) = integral_0^x V dx
    V_mid = (V[:-1] + V[1:]) * 0.5
    M_int = np.cumsum(V_mid * np.diff(x_ft))
    M = np.concatenate([[0.0], M_int])

    Mmax = float(np.max(np.abs(M)))
    Vmax = float(np.max(np.abs(V)))

    # Deflection:
    # curvature k = M / (E I) with consistent units: M in lb-in, E in psi, I in in^4 => k in 1/in
    if E_psi <= 0 or I_in4 <= 0:
        dmax = float("nan")
    else:
        x_in = x_ft * 12.0
        M_lbin = M * 12.0
        k = M_lbin / (E_psi * I_in4)  # 1/in

        # integrate twice with boundary conditions y(0)=0, y(L)=0
        # theta(x) = C1 + integral k dx
        k_int = np.cumsum((k[:-1] + k[1:]) * 0.5 * np.diff(x_in))
        k_int = np.concatenate([[0.0], k_int])

        # y(x) = C2 + C1 x + integral_0^x (integral_0^s k du) ds
        # Let A(x)=integral_0^x k_int ds
        A = np.cumsum((k_int[:-1] + k_int[1:]) * 0.5 * np.diff(x_in))
        A = np.concatenate([[0.0], A])

        # Enforce y(0)=0 => C2=0
        # Enforce y(L)=0 => 0 = C1*L + A(L) => C1 = -A(L)/L
        L_in = float(L_ft * 12.0)
        C1 = -A[-1] / L_in if L_in > 0 else 0.0
        y = C1 * x_in + A
        dmax = float(np.max(np.abs(y)))

    return BeamResult(Mmax_lbft=Mmax, Vmax_lb=Vmax, defl_max_in=dmax)


def beam_uniform(
    L_ft: float,
    w_lbft: float,
    E_psi: float,
    I_in4: float,
) -> BeamResult:
    L_ft = float(L_ft)
    w = float(w_lbft)
    if L_ft <= 0:
        return BeamResult(float("nan"), float("nan"), float("nan"))
    Mmax = abs(w) * L_ft**2 / 8.0
    Vmax = abs(w) * L_ft / 2.0

    if E_psi <= 0 or I_in4 <= 0:
        dmax = float("nan")
    else:
        L_in = L_ft * 12.0
        w_lbin = w / 12.0  # lb/in
        dmax = 5.0 * w_lbin * L_in**4 / (384.0 * E_psi * I_in4)

    return BeamResult(Mmax_lbft=float(Mmax), Vmax_lb=float(Vmax), defl_max_in=float(dmax))


# -----------------------------
# ACI 347R-14 pressure (inch-pound)
# -----------------------------
def cw_unit_weight_coeff(w_pcf: float) -> float:
    # Cw = w/145 (common implementation for ACI 347R-14 inch-pound tables)
    if w_pcf <= 0:
        return float("nan")
    return w_pcf / 145.0

def cc_chem_coeff(mix_category: str, retarder: bool) -> float:
    # Conservative categorical mapping (user-visible)
    # "Normal" = 1.0, "Retarded/high-cementitious" increases Cc
    base = {
        "normal": 1.00,
        "high_cementitious": 1.10,
        "retarded": 1.20,
        "accelerated": 0.90,
    }.get(mix_category, 1.00)
    if retarder and mix_category != "retarded":
        base = max(base, 1.20)
    return float(base)

def aci347r14_lateral_pressure_psf(
    *,
    element_type: str,          # "wall" or "column"
    height_ft: float,
    w_pcf: float,
    T_F: float,
    R_ftph: float,
    slump_in: float,
    internal_vib_depth_ft: float,
    mix_category: str,
    retarder_included: bool,
    is_scc: bool,
    pumped_from_base: bool,
) -> Dict[str, float | str]:
    """
    Returns:
      p_cap_psf: governing max lateral pressure (cap)
      p_hydro_psf: hydrostatic at base
      p_empirical_psf: empirical max pressure (if applicable)
      p_min_psf: minimum pressure
      controlling_eq: text
      Cc, Cw
    """
    height_ft = max(float(height_ft), 0.0)
    w_pcf = max(float(w_pcf), 0.0)
    T_F = max(float(T_F), 1.0)
    R_ftph = max(float(R_ftph), 0.0)

    Cc = cc_chem_coeff(mix_category, retarder_included)
    Cw = cw_unit_weight_coeff(w_pcf)

    p_hydro = w_pcf * height_ft  # psf

    # SCC / high-slump / deep vibration: conservative hydrostatic
    if is_scc:
        p_cap = p_hydro
        eq = "Hydrostatic (SCC selected)"
        # Pumping surge (minimum 25% increase allowance)
        if pumped_from_base:
            p_cap = 1.25 * p_cap
            eq += " + 25% pumping surge"
        return {
            "p_cap_psf": p_cap,
            "p_hydro_psf": p_hydro,
            "p_empirical_psf": float("nan"),
            "p_min_psf": float("nan"),
            "Cc": Cc,
            "Cw": Cw,
            "controlling_eq": eq,
        }

    # Applicability limits for empirical table: conservative fallback to hydrostatic
    if slump_in > 7.0 or internal_vib_depth_ft > 4.0:
        p_cap = p_hydro
        eq = "Hydrostatic (slump>7 in or vib depth>4 ft)"
        if pumped_from_base:
            p_cap = 1.25 * p_cap
            eq += " + 25% pumping surge"
        return {
            "p_cap_psf": p_cap,
            "p_hydro_psf": p_hydro,
            "p_empirical_psf": float("nan"),
            "p_min_psf": float("nan"),
            "Cc": Cc,
            "Cw": Cw,
            "controlling_eq": eq,
        }

    # Minimum
    p_min = 600.0 * Cw

    # Empirical max pressure (Table 4.2.2.1a):
    # walls: 150 + 9000 R / T
    # columns: 150 + 43400 / T + 2800 R / T  (conservative)
    if element_type == "wall":
        p_emp = Cc * Cw * (150.0 + 9000.0 * R_ftph / T_F)
        eq = "ACI 347R-14 (Wall): Cc*Cw*(150 + 9000R/T)"
    else:
        p_emp = Cc * Cw * (150.0 + 43400.0 / T_F + 2800.0 * R_ftph / T_F)
        eq = "ACI 347R-14 (Column): Cc*Cw*(150 + 43400/T + 2800R/T)"

    # Governing cap
    p_cap = min(max(p_min, p_emp), p_hydro)

    if pumped_from_base:
        # Minimum 25% increase allowance (surge) applied to cap, limited by hydro if you wish.
        p_cap = 1.25 * p_cap
        eq += " + 25% pumping surge"
        # Keep hydrostatic at base as a hard upper bound unless user wants otherwise.
        p_cap = min(p_cap, 1.25 * p_hydro)

    return {
        "p_cap_psf": float(p_cap),
        "p_hydro_psf": float(p_hydro),
        "p_empirical_psf": float(p_emp),
        "p_min_psf": float(p_min),
        "Cc": float(Cc),
        "Cw": float(Cw),
        "controlling_eq": eq,
    }


def pressure_at_depth_psf(depth_ft: float, w_pcf: float, p_cap_psf: float) -> float:
    """p(depth) = min(w*depth, p_cap)"""
    return float(min(w_pcf * max(depth_ft, 0.0), p_cap_psf))


def build_pressure_profile(
    height_ft: float,
    w_pcf: float,
    p_cap_psf: float,
    seg_ft: float,
) -> pd.DataFrame:
    """
    Returns a dataframe of segments from top (depth=0) to bottom (depth=H):
      depth_top, depth_bot, p_top, p_bot, p_mid, p_avg
    """
    H = max(float(height_ft), 0.0)
    seg = max(float(seg_ft), 0.25)
    n = int(math.ceil(H / seg)) if H > 0 else 1
    bounds = [min(i * seg, H) for i in range(n + 1)]

    rows = []
    for i in range(n):
        z0 = bounds[i]
        z1 = bounds[i + 1]
        zm = 0.5 * (z0 + z1)
        p0 = pressure_at_depth_psf(z0, w_pcf, p_cap_psf)
        p1 = pressure_at_depth_psf(z1, w_pcf, p_cap_psf)
        pm = pressure_at_depth_psf(zm, w_pcf, p_cap_psf)

        # Average pressure over segment (piecewise: linear up to cap)
        # Use fine sampling for robustness around the cap transition.
        zs = np.linspace(z0, z1, 31)
        ps = np.minimum(w_pcf * zs, p_cap_psf)
        pavg = float(np.trapezoid(ps, zs) / max((z1 - z0), 1e-9))

        rows.append({
            "Segment": i + 1,
            "DepthTop_ft": z0,
            "DepthBot_ft": z1,
            "ElevTop_ft": H - z0,
            "ElevBot_ft": H - z1,
            "p_top_psf": p0,
            "p_bot_psf": p1,
            "p_mid_psf": pm,
            "p_avg_psf": pavg,
        })
    return pd.DataFrame(rows)


# -----------------------------
# NDS presets (dimension lumber)
# -----------------------------
# NOTE: These are COMMON reference design values used in practice; you must verify against your NDS Supplement / jurisdiction.
# Units: psi (Fb, Fv), psi (E)

# -----------------------------
# NDS design values (from CSV if provided)
# -----------------------------
NDS_CSV_FILENAME = "NDS_Supplement_2018_Tables_4A_4B.csv"
NDS_CSV_PATH = os.path.join(os.path.dirname(__file__), NDS_CSV_FILENAME)

NDS_DF: Optional[pd.DataFrame] = None
try:
    NDS_DF = pd.read_csv(NDS_CSV_PATH)
except Exception:
    NDS_DF = None

# Fallback minimal presets if CSV is not present
NDS_PRESETS = {
    "SPF No.2": {"Fb": 875, "Fv": 135, "E": 1_300_000},
    "DF-L No.2": {"Fb": 900, "Fv": 180, "E": 1_600_000},
    "SYP No.2": {"Fb": 1_100, "Fv": 175, "E": 1_600_000},
    "HF No.2": {"Fb": 925, "Fv": 150, "E": 1_400_000},
    "LVL 2.0E (generic)": {"Fb": 2_600, "Fv": 285, "E": 2_000_000},
}


def nds_size_class(size: str) -> str:
    """Maps nominal member size to NDS width classification labels used in the CSV."""
    try:
        nominal = int(size.split("x")[1])
    except Exception:
        return '2" & wider'
    if nominal <= 4:
        return '4" wide'
    if nominal in (5, 6):
        return '5" - 6" wide'
    if nominal == 8:
        return '8" wide'
    if nominal == 10:
        return '10" wide'
    if nominal == 12:
        return '12" wide'
    return '2" & wider'

def nds_lookup_base(species: str, grade: str, member_size: str) -> Optional[Dict[str, float]]:
    """Returns base (Fb, Fv, E) from NDS CSV for the given species/grade and member size."""
    if NDS_DF is None:
        b = NDS_PRESETS.get(species, None)
        return b if isinstance(b, dict) else None

    size_class = nds_size_class(member_size)
    table_pref = None
    if isinstance(member_size, str) and member_size.startswith("2x"):
        table_pref = "4A"
    elif isinstance(member_size, str) and member_size.startswith("4x"):
        table_pref = "4B"

    d = NDS_DF
    d0 = d[(d["species"] == species) & (d["grade"] == grade)].copy()
    if d0.empty:
        return None

    # Prefer matching table (4A for 2x, 4B for 4x) and exact size class; then fall back progressively.
    candidates = []
    if table_pref:
        candidates.append(d0[(d0["table"] == table_pref) & (d0["size_classification"] == size_class)])
    candidates.append(d0[d0["size_classification"] == size_class])
    if table_pref:
        candidates.append(d0[(d0["table"] == table_pref) & (d0["size_classification"].isin(['2" & wider', '2" - 4" wide']))])
    candidates.append(d0[d0["size_classification"].isin(['2" & wider', '2" - 4" wide'])])
    candidates.append(d0)

    row = None
    for c in candidates:
        if not c.empty:
            row = c.iloc[0]
            break
    if row is None:
        return None

    Fb = float(row.get("Fb_psi", float("nan")))
    Fv = float(row.get("Fv_psi", float("nan")))
    E  = float(row.get("E_psi", float("nan")))
    if not (math.isfinite(Fb) and math.isfinite(Fv) and math.isfinite(E)):
        return None
    return {"Fb": Fb, "Fv": Fv, "E": E}

def nds_species_options() -> List[Dict[str, str]]:
    if NDS_DF is None:
        return [{"label": k, "value": k} for k in sorted(NDS_PRESETS.keys())]
    species = sorted([s for s in NDS_DF["species"].dropna().unique()])
    return [{"label": s, "value": s} for s in species]

def nds_grade_options_for_species(species: str) -> List[Dict[str, str]]:
    if NDS_DF is None:
        return [{"label": "Preset", "value": "Preset"}]
    d0 = NDS_DF[NDS_DF["species"] == species]
    grades = sorted([g for g in d0["grade"].dropna().unique()])
    return [{"label": g, "value": g} for g in grades]

# Defaults for initial app load
if NDS_DF is None:
    DEFAULT_NDS_SPECIES = sorted(NDS_PRESETS.keys())[0]
    DEFAULT_NDS_GRADE = "Preset"
else:
    DEFAULT_NDS_SPECIES = sorted([s for s in NDS_DF["species"].dropna().unique()])[0]
    _g = nds_grade_options_for_species(DEFAULT_NDS_SPECIES)
    DEFAULT_NDS_GRADE = _g[0]["value"] if _g else ""

def nds_reference_size_class(d0: pd.DataFrame) -> Optional[str]:
    for pref in ['2" - 4" wide', '4" wide', '2" & wider']:
        if pref in set(d0["size_classification"].dropna().unique()):
            return pref
    return d0["size_classification"].dropna().iloc[0] if not d0.empty else None

def nds_lookup_reference(species: str, grade: str) -> Optional[Dict[str, float]]:
    """Returns reference (Fb, Fv, E) from NDS CSV for the given species/grade."""
    if NDS_DF is None:
        b = NDS_PRESETS.get(species, None)
        return b if isinstance(b, dict) else None

    d0 = NDS_DF[(NDS_DF["species"] == species) & (NDS_DF["grade"] == grade)].copy()
    if d0.empty:
        return None
    ref_class = nds_reference_size_class(d0)
    if not ref_class:
        return None
    row = d0[d0["size_classification"] == ref_class].iloc[0]

    Fb = float(row.get("Fb_psi", float("nan")))
    Fv = float(row.get("Fv_psi", float("nan")))
    E  = float(row.get("E_psi", float("nan")))
    if not (math.isfinite(Fb) and math.isfinite(Fv) and math.isfinite(E)):
        return None
    return {"Fb": Fb, "Fv": Fv, "E": E}

def nds_size_factor(species: str, grade: str, member_size: str) -> float:
    """Returns Cf (size factor for Fb) using NDS size classifications."""
    if NDS_DF is None:
        return 1.0
    d0 = NDS_DF[(NDS_DF["species"] == species) & (NDS_DF["grade"] == grade)].copy()
    if d0.empty:
        return 1.0
    size_class = nds_size_class(member_size)
    ref_class = nds_reference_size_class(d0)
    if not ref_class:
        return 1.0

    ref_row = d0[d0["size_classification"] == ref_class]
    size_row = d0[d0["size_classification"] == size_class]
    if ref_row.empty or size_row.empty:
        return 1.0
    Fb_ref = float(ref_row.iloc[0].get("Fb_psi", float("nan")))
    Fb_size = float(size_row.iloc[0].get("Fb_psi", float("nan")))
    if not (math.isfinite(Fb_ref) and math.isfinite(Fb_size)) or Fb_ref <= 0:
        return 1.0
    return Fb_size / Fb_ref

def nds_cm_factor(is_wet: bool) -> float:
    return 0.85 if is_wet else 1.0

def nds_ct_factor(is_hot: bool) -> float:
    return 0.90 if is_hot else 1.0
def apply_nds_factors(base: Dict[str, float], CD: float, CM: float, Ct: float, Cf: float) -> Dict[str, float]:
    """
    Simplified factor application for formwork (ASD-style).
    Fb' = Fb * CD * CM * Ct * Cf
    Fv' = Fv * CD * CM * Ct
    E'  = E  * CM * Ct
    """
    Fb = base.get("Fb", float("nan"))
    Fv = base.get("Fv", float("nan"))
    E  = base.get("E", float("nan"))
    return {
        "Fb": Fb * CD * CM * Ct * Cf,
        "Fv": Fv * CD * CM * Ct,
        "E":  E  * CM * Ct,
    }


def resolve_cd_value(cd_preset: float, cd_custom: float) -> Tuple[float, str]:
    cd_preset_val = safe_float(cd_preset, 1.25)
    cd_custom_val = safe_float(cd_custom, float("nan"))
    if math.isfinite(cd_custom_val) and cd_custom_val > 0:
        return cd_custom_val, "custom"
    return cd_preset_val, "preset"


def fmt_nds_value(value, nd: int = 0) -> str:
    try:
        val = float(value)
    except Exception:
        return "-"
    if not math.isfinite(val):
        return "-"
    if nd <= 0:
        return f"{val:,.0f}"
    return f"{val:,.{nd}f}"


def format_dim_label(size: str) -> str:
    dims = DIMLUMBER_DB.get(size)
    if not dims:
        return size or "-"
    b, d = dims
    return f"{size} ({b:.1f} x {d:.1f} in)"


def build_nds_summary_card(
    title: str,
    size_label: str,
    base: Dict[str, float],
    adjusted: Dict[str, float],
    CD: float,
    CM: float,
    Ct: float,
    Cf: float,
    cd_source: str,
) -> html.Div:
    def factor_cell(value):
        return "n/a" if value is None else fmt_nds_value(value, 2)

    rows = [
        ("Fb", base.get("Fb"), CD, CM, Ct, Cf, adjusted.get("Fb")),
        ("Fv", base.get("Fv"), CD, CM, Ct, None, adjusted.get("Fv")),
        ("E",  base.get("E"), None, CM, Ct, None, adjusted.get("E")),
    ]

    cd_label = fmt_nds_value(CD, 2)
    return html.Div(
        className="nds-summary-card",
        children=[
            html.Div(
                className="nds-summary-header",
                children=[
                    html.Div([
                        html.Div(title, className="nds-summary-title"),
                        html.Div(size_label, className="field-help"),
                    ]),
                    html.Div(f"CD {cd_label} ({cd_source})", className="nds-pill"),
                ],
            ),
            html.Table(
                className="nds-table",
                children=[
                    html.Thead(html.Tr([
                        html.Th("Value"),
                        html.Th("Base (ref)"),
                        html.Th("Cd"),
                        html.Th("Cm"),
                        html.Th("Ct"),
                        html.Th("Cf"),
                        html.Th("Adjusted"),
                    ])),
                    html.Tbody([
                        html.Tr([
                            html.Td(label),
                            html.Td(fmt_nds_value(base_val, 0)),
                            html.Td(factor_cell(cd_val)),
                            html.Td(factor_cell(cm_val)),
                            html.Td(factor_cell(ct_val)),
                            html.Td(factor_cell(cf_val)),
                            html.Td(fmt_nds_value(adj_val, 0)),
                        ])
                        for label, base_val, cd_val, cm_val, ct_val, cf_val, adj_val in rows
                    ]),
                ],
            ),
            html.Div("Cf applies to Fb only. E excludes CD per NDS.", className="field-help"),
        ],
    )


def build_formwork_diagram_figure(
    stud_size: str,
    waler_size: str,
    stud_spacing_in: float,
    waler_spacing_in: float,
    tie_spacing_in: float,
    stud_orientation: str,
    form_height_ft: float,
) -> Dict[str, object]:
    stud_b, _ = DIMLUMBER_DB.get(stud_size, (1.5, 3.5))
    waler_b, _ = DIMLUMBER_DB.get(waler_size, (1.5, 5.5))

    stud_spacing = max(safe_float(stud_spacing_in, 16), 4.0)
    waler_spacing = max(safe_float(waler_spacing_in, 24), 4.0)
    tie_spacing = max(safe_float(tie_spacing_in, 24), 4.0)
    height_in = max(safe_float(form_height_ft, 8.0) * 12.0, 12.0)

    vertical_studs = (stud_orientation or "vertical") != "horizontal"
    stud_thk = stud_b
    waler_thk = waler_b

    pad = 10.0
    label_pad = 22.0
    bay_count = 6

    def member_centers(length: float, spacing: float, thickness: float) -> List[float]:
        length = max(length, thickness)
        spacing = max(spacing, 1.0)
        first = thickness / 2.0
        last = length - thickness / 2.0
        if last <= first:
            return [length / 2.0]
        count = int(math.floor((last - first) / spacing)) + 1
        centers = [first + i * spacing for i in range(count)]
        if last - centers[-1] > 1e-6:
            centers.append(last)
        return centers

    def tie_positions(length: float, spacing: float) -> List[float]:
        length = max(length, 1.0)
        spacing = max(spacing, 1.0)
        if length <= spacing:
            return [length / 2.0]
        positions = []
        pos = spacing
        while pos <= length + 1e-6:
            positions.append(pos)
            pos += spacing
        return positions

    if vertical_studs:
        bay_spacing = stud_spacing
        width = bay_count * bay_spacing + stud_thk
        height = height_in
        stud_positions = member_centers(width, stud_spacing, stud_thk)
        waler_positions = member_centers(height, waler_spacing, waler_thk)
        tie_x_positions = tie_positions(width - stud_thk / 2.0, tie_spacing)
        tie_y_positions = waler_positions
    else:
        bay_spacing = waler_spacing
        width = bay_count * bay_spacing + waler_thk
        height = height_in
        waler_positions = member_centers(width, waler_spacing, waler_thk)
        stud_positions = member_centers(height, stud_spacing, stud_thk)
        tie_x_positions = waler_positions
        tie_y_positions = tie_positions(height - stud_thk / 2.0, tie_spacing)

    x_min = -pad - 18.0
    y_min = -pad
    x_max = width + pad + 18.0
    y_max = height + label_pad + pad

    shapes = [
        {
            "type": "rect",
            "x0": 0,
            "y0": 0,
            "x1": width,
            "y1": height,
            "line": {"color": "#334155", "width": 2},
            "fillcolor": "rgba(15,23,42,0.03)",
        }
    ]

    stud_color = "rgba(51,65,85,0.18)"
    waler_color = "rgba(15,118,110,0.18)"

    if vertical_studs:
        for x in stud_positions:
            shapes.append({
                "type": "rect",
                "x0": x - stud_thk / 2,
                "x1": x + stud_thk / 2,
                "y0": 0,
                "y1": height,
                "line": {"color": "#334155", "width": 1},
                "fillcolor": stud_color,
            })
        for y in waler_positions:
            shapes.append({
                "type": "rect",
                "x0": 0,
                "x1": width,
                "y0": y - waler_thk / 2,
                "y1": y + waler_thk / 2,
                "line": {"color": "#0f766e", "width": 1},
                "fillcolor": waler_color,
            })
    else:
        for y in stud_positions:
            shapes.append({
                "type": "rect",
                "x0": 0,
                "x1": width,
                "y0": y - stud_thk / 2,
                "y1": y + stud_thk / 2,
                "line": {"color": "#334155", "width": 1},
                "fillcolor": stud_color,
            })
        for x in waler_positions:
            shapes.append({
                "type": "rect",
                "x0": x - waler_thk / 2,
                "x1": x + waler_thk / 2,
                "y0": 0,
                "y1": height,
                "line": {"color": "#0f766e", "width": 1},
                "fillcolor": waler_color,
            })

    tie_r = max(0.5, min(stud_thk, waler_thk) * 0.2)
    for x in tie_x_positions:
        for y in tie_y_positions:
            shapes.append({
                "type": "circle",
                "x0": x - tie_r,
                "x1": x + tie_r,
                "y0": y - tie_r,
                "y1": y + tie_r,
                "line": {"color": "#c2410c", "width": 1},
                "fillcolor": "rgba(249,115,22,0.8)",
            })

    annotations = []
    spacing_font = {"size": 11, "color": "#1f2937"}

    if vertical_studs and len(stud_positions) > 1:
        annotations.append({
            "x": stud_positions[1],
            "y": height + pad,
            "ax": stud_positions[0],
            "ay": height + pad,
            "xref": "x",
            "yref": "y",
            "axref": "x",
            "ayref": "y",
            "text": f"Stud spacing {stud_spacing:.0f} in",
            "showarrow": True,
            "arrowside": "end+start",
            "arrowhead": 3,
            "arrowwidth": 1,
            "arrowcolor": "#1f2937",
            "font": spacing_font,
        })
        if len(waler_positions) > 1:
            annotations.append({
                "x": width + pad,
                "y": waler_positions[1],
                "ax": width + pad,
                "ay": waler_positions[0],
                "xref": "x",
                "yref": "y",
                "axref": "x",
                "ayref": "y",
                "text": f"Waler spacing {waler_spacing:.0f} in",
                "showarrow": True,
                "arrowside": "end+start",
                "arrowhead": 3,
                "arrowwidth": 1,
                "arrowcolor": "#1f2937",
                "font": spacing_font,
            })
        if len(tie_x_positions) > 1:
            annotations.append({
                "x": tie_x_positions[1],
                "y": waler_positions[0],
                "ax": tie_x_positions[0],
                "ay": waler_positions[0],
                "xref": "x",
                "yref": "y",
                "axref": "x",
                "ayref": "y",
                "text": f"Tie spacing {tie_spacing:.0f} in",
                "showarrow": True,
                "arrowside": "end+start",
                "arrowhead": 3,
                "arrowwidth": 1,
                "arrowcolor": "#1f2937",
                "font": spacing_font,
            })
    elif not vertical_studs and len(waler_positions) > 1:
        annotations.append({
            "x": waler_positions[1],
            "y": height + pad,
            "ax": waler_positions[0],
            "ay": height + pad,
            "xref": "x",
            "yref": "y",
            "axref": "x",
            "ayref": "y",
            "text": f"Waler spacing {waler_spacing:.0f} in",
            "showarrow": True,
            "arrowside": "end+start",
            "arrowhead": 3,
            "arrowwidth": 1,
            "arrowcolor": "#1f2937",
            "font": spacing_font,
        })
        if len(stud_positions) > 1:
            annotations.append({
                "x": width + pad,
                "y": stud_positions[1],
                "ax": width + pad,
                "ay": stud_positions[0],
                "xref": "x",
                "yref": "y",
                "axref": "x",
                "ayref": "y",
                "text": f"Stud spacing {stud_spacing:.0f} in",
                "showarrow": True,
                "arrowside": "end+start",
                "arrowhead": 3,
                "arrowwidth": 1,
                "arrowcolor": "#1f2937",
                "font": spacing_font,
            })
        if len(tie_y_positions) > 1:
            annotations.append({
                "x": waler_positions[0],
                "y": tie_y_positions[1],
                "ax": waler_positions[0],
                "ay": tie_y_positions[0],
                "xref": "x",
                "yref": "y",
                "axref": "x",
                "ayref": "y",
                "text": f"Tie spacing {tie_spacing:.0f} in",
                "showarrow": True,
                "arrowside": "end+start",
                "arrowhead": 3,
                "arrowwidth": 1,
                "arrowcolor": "#1f2937",
                "font": spacing_font,
            })

    annotations.append({
        "x": -pad,
        "y": height,
        "ax": -pad,
        "ay": 0,
        "xref": "x",
        "yref": "y",
        "axref": "x",
        "ayref": "y",
        "text": f"Form height {height / 12.0:.1f} ft",
        "showarrow": True,
        "arrowside": "end+start",
        "arrowhead": 3,
        "arrowwidth": 1,
        "arrowcolor": "#1f2937",
        "font": spacing_font,
    })

    size_label = f"Stud size: {format_dim_label(stud_size)}<br>Waler size: {format_dim_label(waler_size)}"
    annotations.append({
        "x": 0,
        "y": height + label_pad,
        "xref": "x",
        "yref": "y",
        "text": size_label,
        "showarrow": False,
        "xanchor": "left",
        "align": "left",
        "font": {"size": 11, "color": "#0f172a"},
        "bgcolor": "rgba(255,255,255,0.9)",
        "bordercolor": "rgba(15,23,42,0.12)",
        "borderwidth": 1,
        "borderpad": 4,
    })

    return {
        "data": [],
        "layout": {
            "xaxis": {
                "range": [x_min, x_max],
                "showgrid": False,
                "zeroline": False,
                "visible": False,
            },
            "yaxis": {
                "range": [y_min, y_max],
                "showgrid": False,
                "zeroline": False,
                "visible": False,
                "scaleanchor": "x",
            },
            "shapes": shapes,
            "annotations": annotations,
            "margin": {"l": 10, "r": 10, "t": 10, "b": 10},
            "paper_bgcolor": "rgba(0,0,0,0)",
            "plot_bgcolor": "rgba(0,0,0,0)",
        },
    }


# -----------------------------
# Tie capacities (SWL) presets (lb)
# -----------------------------
SNAP_TIE_SWL_LB = {
    "snap_tie": 2250,
    "heavy_snap_tie": 3750,
}
TAPER_TIE_SWL_LB = {
    "1/2\" taper tie": 7000,
    "5/8\" taper tie": 12000,
    "3/4\" taper tie": 17000,
}
COIL_ROD_SWL_LB = {
    "3/8\"": 4000,
    "1/2\"": 6500,
    "5/8\"": 9500,
    "3/4\"": 14000,
    "7/8\"": 18500,
    "1\"": 25000,
}

def tie_swl_lb(tie_type: str, tie_size: Optional[str]) -> float:
    if tie_type in ("snap_tie", "heavy_snap_tie"):
        return float(SNAP_TIE_SWL_LB.get(tie_type, float("nan")))
    if tie_type == "taper_tie":
        return float(TAPER_TIE_SWL_LB.get(tie_size or "", float("nan")))
    if tie_type == "coil_rod":
        return float(COIL_ROD_SWL_LB.get(tie_size or "", float("nan")))
    return float("nan")


# -----------------------------
# Utilization calculations
# -----------------------------
def util_ratio(demand: float, capacity: float) -> float:
    if capacity <= 0 or math.isnan(capacity) or math.isnan(demand):
        return float("nan")
    return demand / capacity

def defl_allowable_in(L_in: float, limit_ratio: float) -> float:
    if limit_ratio <= 0:
        return float("nan")
    return L_in / limit_ratio

@dataclass
class MemberUtil:
    member: str
    check: str
    demand: float
    capacity: float
    util: float
    units: str

def check_beam_section(
    *,
    member_name: str,
    beam: BeamResult,
    S_in3: float,
    A_in2: float,
    Fb_allow: float,
    Fv_allow: float,
    L_in: float,
    defl_limit_ratio: float,
    V_shear_override_lb: Optional[float] = None,
) -> List[MemberUtil]:
    out: List[MemberUtil] = []
    # Bending
    M_lbin = beam.Mmax_lbft * 12.0
    fb = M_lbin / S_in3 if S_in3 > 0 else float("nan")
    out.append(MemberUtil(
        member=member_name,
        check="Bending (fb ≤ Fb)",
        demand=fb,
        capacity=Fb_allow,
        util=util_ratio(fb, Fb_allow),
        units="psi"
    ))
    # Shear (rectangular approx: tau = 1.5*V/A)
    V_use = beam.Vmax_lb if V_shear_override_lb is None else float(V_shear_override_lb)
    tau = 1.5 * V_use / A_in2 if A_in2 > 0 else float("nan")
    out.append(MemberUtil(
        member=member_name,
        check="Shear (τ ≤ Fv)",
        demand=tau,
        capacity=Fv_allow,
        util=util_ratio(tau, Fv_allow),
        units="psi"
    ))
    # Deflection
    da = defl_allowable_in(L_in, defl_limit_ratio)
    out.append(MemberUtil(
        member=member_name,
        check=f"Deflection (Δ ≤ L/{int(defl_limit_ratio)})",
        demand=beam.defl_max_in,
        capacity=da,
        util=util_ratio(beam.defl_max_in, da),
        units="in"
    ))
    return out


def compute_member_utils_uniform(
    *,
    p_psf: float,
    plywood_t_in: float,
    stud_size: str,
    waler_size: str,
    stud_spacing_in: float,
    waler_spacing_in: float,
    tie_spacing_in: float,
    ply_Fb: float,
    ply_Fv: float,
    ply_E: float,
    stud_Fb: float,
    stud_Fv: float,
    stud_E: float,
    waler_Fb: float,
    waler_Fv: float,
    waler_E: float,
    stud_orientation: str,
    defl_ratio_ply: float,
    defl_ratio_stud: float,
    defl_ratio_waler: float,
) -> List[MemberUtil]:
    """
    Baseline single-point utilization using uniform pressure p_psf (conservative).
    """
    p = max(float(p_psf), 0.0)

    s_stud_ft = in_to_ft(max(stud_spacing_in, 0.0))
    s_waler_ft = in_to_ft(max(waler_spacing_in, 0.0))
    s_tie_ft = in_to_ft(max(tie_spacing_in, 0.0))

    # Plywood
    # Vertical studs: plywood spans between studs horizontally, 1-ft tall strip; load = p * stud_spacing (plf) on 1-ft strip
    # Horizontal studs: plywood spans vertically between studs; use 1-ft wide strip; load = p (psf)*1ft = plf, span = stud_spacing
    S_ply, I_ply, A_ply = member_props_plywood_strip(plywood_t_in, 12.0)
    if stud_orientation == "vertical":
        L_ply_ft = s_stud_ft
        w_ply_lbft = p * s_stud_ft
    else:
        L_ply_ft = s_stud_ft
        w_ply_lbft = p * 1.0
    beam_ply = beam_uniform(L_ply_ft, w_ply_lbft, ply_E, I_ply)
    utils = check_beam_section(
        member_name="Plywood",
        beam=beam_ply,
        S_in3=S_ply,
        A_in2=A_ply,
        Fb_allow=ply_Fb,
        Fv_allow=ply_Fv,
        L_in=ft_to_in(L_ply_ft),
        defl_limit_ratio=defl_ratio_ply,
    )

    # Studs
    S_stud, I_stud, A_stud = member_props_dimlumber(stud_size, strong_axis=True)
    if stud_orientation == "vertical":
        L_stud_ft = s_waler_ft
        w_stud_lbft = p * s_stud_ft
    else:
        L_stud_ft = s_waler_ft
        w_stud_lbft = p * s_stud_ft  # conservative
    beam_stud = beam_uniform(L_stud_ft, w_stud_lbft, stud_E, I_stud)
    utils += check_beam_section(
        member_name="Stud",
        beam=beam_stud,
        S_in3=S_stud,
        A_in2=A_stud,
        Fb_allow=stud_Fb,
        Fv_allow=stud_Fv,
        L_in=ft_to_in(L_stud_ft),
        defl_limit_ratio=defl_ratio_stud,
    )

    # Double waler (2 plies)
    S_w, I_w, A_w = member_props_dimlumber(waler_size, strong_axis=True)
    S_w *= 2.0
    I_w *= 2.0
    A_w *= 2.0

    if stud_orientation == "vertical":
        L_w_ft = s_tie_ft
        w_w_lbft = p * s_waler_ft
    else:
        L_w_ft = s_tie_ft
        w_w_lbft = p * s_waler_ft
    beam_w = beam_uniform(L_w_ft, w_w_lbft, waler_E, I_w)
    # NDS convention: check shear at a section located d from the tie (support).
    # Here, d is taken as the selected member depth (e.g., 2x6 -> 5.5 in).
    d_in = DIMLUMBER_DB.get(waler_size, (0.0, 0.0))[1]
    d_ft = float(d_in) / 12.0
    Vd_lb = abs(w_w_lbft) * max(0.0, (L_w_ft / 2.0 - d_ft))
    utils += check_beam_section(
        member_name="Double waler",
        beam=beam_w,
        S_in3=S_w,
        A_in2=A_w,
        Fb_allow=waler_Fb,
        Fv_allow=waler_Fv,
        L_in=ft_to_in(L_w_ft),
        defl_limit_ratio=defl_ratio_waler,
            V_shear_override_lb=Vd_lb,
    )

    return utils


def compute_segment_checks(
    *,
    profile: pd.DataFrame,
    height_ft: float,
    w_pcf: float,
    p_cap_psf: float,
    plywood_t_in: float,
    stud_size: str,
    waler_size: str,
    stud_spacing_in: float,
    waler_spacing_in: float,
    tie_spacing_in: float,
    ply_Fb: float,
    ply_Fv: float,
    ply_E: float,
    stud_Fb: float,
    stud_Fv: float,
    stud_E: float,
    waler_Fb: float,
    waler_Fv: float,
    waler_E: float,
    stud_orientation: str,
    defl_ratio_ply: float,
    defl_ratio_stud: float,
    defl_ratio_waler: float,
    tie_type: str,
    tie_size: Optional[str],
) -> pd.DataFrame:
    """
    Returns per-segment table including:
      - pressure summary
      - governing utilization ratios for plywood/studs/walers/ties at that elevation band
    """
    H = max(float(height_ft), 0.0)
    s_stud_ft = in_to_ft(max(stud_spacing_in, 0.0))
    s_waler_ft = in_to_ft(max(waler_spacing_in, 0.0))
    s_tie_ft = in_to_ft(max(tie_spacing_in, 0.0))

    # Section props
    S_ply, I_ply, A_ply = member_props_plywood_strip(plywood_t_in, 12.0)
    S_stud, I_stud, A_stud = member_props_dimlumber(stud_size, strong_axis=True)
    S_w, I_w, A_w = member_props_dimlumber(waler_size, strong_axis=True)
    S_w *= 2.0; I_w *= 2.0; A_w *= 2.0

    tie_cap = tie_swl_lb(tie_type, tie_size)

    # Precompute waler elevation lines (from top)
    # Spacing applies along wall height direction if member is vertical.
    # Case A (studs vertical): walers are horizontal at vertical spacing s_waler_ft
    # Case B (studs horizontal): walers are vertical; their spacing is s_waler_ft (horizontal), but ties along waler are vertical at s_tie_ft.
    if s_waler_ft <= 0:
        waler_depths = [0.0, H]
    else:
        n_w = int(math.ceil(H / s_waler_ft))
        waler_depths = [min(i * s_waler_ft, H) for i in range(n_w + 1)]

    # Tie "lines" along height for vertical walers (studs horizontal case)
    if s_tie_ft <= 0:
        tie_depths = [0.0, H]
    else:
        n_t = int(math.ceil(H / s_tie_ft))
        tie_depths = [min(i * s_tie_ft, H) for i in range(n_t + 1)]

    def max_util_from_utils(utils: List[MemberUtil], member: str) -> float:
        vals = [u.util for u in utils if u.member == member and not math.isnan(u.util)]
        return float(max(vals)) if vals else float("nan")

    # Helper: beam util at a vertical span with trapezoidal load derived from pressure at endpoints
    def util_vertical_span(
        *,
        member: str,
        z_top: float,
        z_bot: float,
        trib_width_ft: float,
        S_in3: float,
        I_in4: float,
        A_in2: float,
        Fb_allow: float,
        Fv_allow: float,
        E_psi: float,
        defl_ratio: float,
    ) -> float:
        L = max(z_bot - z_top, 0.0)
        if L <= 0:
            return float("nan")
        # load intensity along member: w(x)=p(z)*trib_width
        # z varies linearly from z_top to z_bot across the span
        x = np.linspace(0.0, L, 201)
        z = z_top + x  # depth from top
        p = np.minimum(w_pcf * z, p_cap_psf)
        w_lbft = p * trib_width_ft  # lb/ft
        beam = beam_simply_supported_distributed(L, w_lbft, x, E_psi, I_in4)
        utils = check_beam_section(
            member_name=member,
            beam=beam,
            S_in3=S_in3,
            A_in2=A_in2,
            Fb_allow=Fb_allow,
            Fv_allow=Fv_allow,
            L_in=ft_to_in(L),
            defl_limit_ratio=defl_ratio,
        )
        return max_util_from_utils(utils, member)

    # Plywood utilization function at a segment midpoint
    def ply_util_at(depth_mid: float) -> float:
        p = pressure_at_depth_psf(depth_mid, w_pcf, p_cap_psf)
        if stud_orientation == "vertical":
            # horizontal span between studs, use local p
            L = s_stud_ft
            w_lbft = p * s_stud_ft
            beam = beam_uniform(L, w_lbft, ply_E, I_ply)
            utils = check_beam_section(
                member_name="Plywood",
                beam=beam,
                S_in3=S_ply,
                A_in2=A_ply,
                Fb_allow=ply_Fb,
                Fv_allow=ply_Fv,
                L_in=ft_to_in(L),
                defl_limit_ratio=defl_ratio_ply,
            )
            return max_util_from_utils(utils, "Plywood")
        else:
            # vertical span between horizontal studs: trapezoid across that span
            # determine enclosing stud span based on stud_spacing (vertical)
            if s_stud_ft <= 0:
                return float("nan")
            i = int(depth_mid // s_stud_ft)
            z0 = min(i * s_stud_ft, H)
            z1 = min((i + 1) * s_stud_ft, H)
            # 1-ft wide strip
            return util_vertical_span(
                member="Plywood",
                z_top=z0,
                z_bot=z1,
                trib_width_ft=1.0,
                S_in3=S_ply,
                I_in4=I_ply,
                A_in2=A_ply,
                Fb_allow=ply_Fb,
                Fv_allow=ply_Fv,
                E_psi=ply_E,
                defl_ratio=defl_ratio_ply,
            )

    def stud_util_at(depth_mid: float) -> float:
        p = pressure_at_depth_psf(depth_mid, w_pcf, p_cap_psf)
        if stud_orientation == "vertical":
            if s_waler_ft <= 0:
                return float("nan")
            i = int(depth_mid // s_waler_ft)
            z0 = min(i * s_waler_ft, H)
            z1 = min((i + 1) * s_waler_ft, H)
            return util_vertical_span(
                member="Stud",
                z_top=z0,
                z_bot=z1,
                trib_width_ft=s_stud_ft,
                S_in3=S_stud,
                I_in4=I_stud,
                A_in2=A_stud,
                Fb_allow=stud_Fb,
                Fv_allow=stud_Fv,
                E_psi=stud_E,
                defl_ratio=defl_ratio_stud,
            )
        else:
            # horizontal stud: uniform beam between walers; tributary height = stud spacing (vertical)
            L = s_waler_ft
            w_lbft = p * s_stud_ft  # conservative (stud trib width assumed)
            beam = beam_uniform(L, w_lbft, stud_E, I_stud)
            utils = check_beam_section(
                member_name="Stud",
                beam=beam,
                S_in3=S_stud,
                A_in2=A_stud,
                Fb_allow=stud_Fb,
                Fv_allow=stud_Fv,
                L_in=ft_to_in(L),
                defl_limit_ratio=defl_ratio_stud,
            )
            return max_util_from_utils(utils, "Stud")

    def waler_util_at(depth_mid: float) -> float:
        p = pressure_at_depth_psf(depth_mid, w_pcf, p_cap_psf)
        if stud_orientation == "vertical":
            # horizontal waler span between ties; tributary height ~ waler spacing
            L = s_tie_ft
            w_lbft = p * s_waler_ft
            beam = beam_uniform(L, w_lbft, waler_E, I_w)
            utils = check_beam_section(
                member_name="Double waler",
                beam=beam,
                S_in3=S_w,
                A_in2=A_w,
                Fb_allow=waler_Fb,
                Fv_allow=waler_Fv,
                L_in=ft_to_in(L),
                defl_limit_ratio=defl_ratio_waler,
            )
            return max_util_from_utils(utils, "Double waler")
        else:
            # vertical waler between ties (vertical spacing = tie spacing)
            if s_tie_ft <= 0:
                return float("nan")
            i = int(depth_mid // s_tie_ft)
            z0 = min(i * s_tie_ft, H)
            z1 = min((i + 1) * s_tie_ft, H)
            # tributary width = waler spacing (horizontal)
            return util_vertical_span(
                member="Double waler",
                z_top=z0,
                z_bot=z1,
                trib_width_ft=s_waler_ft,
                S_in3=S_w,
                I_in4=I_w,
                A_in2=A_w,
                Fb_allow=waler_Fb,
                Fv_allow=waler_Fv,
                E_psi=waler_E,
                defl_ratio=defl_ratio_waler,
            )

    def tie_utils_at(depth_mid: float) -> Dict[str, float]:
        """Returns utilization for interior/edge/corner tie at that elevation."""
        p = pressure_at_depth_psf(depth_mid, w_pcf, p_cap_psf)
        # Tributary dimensions:
        # - along waler: tie spacing (s_tie_ft)
        # - perpendicular: waler spacing (s_waler_ft) when walers horizontal; when walers vertical, perpendicular is waler spacing too.
        A_int = s_tie_ft * s_waler_ft
        # Edge along waler direction: half tributary length
        A_edge = 0.5 * s_tie_ft * s_waler_ft
        # Corner: half in both directions
        A_corner = 0.25 * s_tie_ft * s_waler_ft
        # Top/bottom edge effect: if depth is within half a waler spacing of top/bottom, also reduce vertical tributary.
        # We show this explicitly as an additional "Top/Bottom edge" case.
        A_tb_edge = s_tie_ft * (0.5 * s_waler_ft)

        dem_int = p * A_int
        dem_edge = p * A_edge
        dem_corner = p * A_corner
        dem_tb = p * A_tb_edge
        return {
            "Tie (interior)": util_ratio(dem_int, tie_cap),
            "Tie (edge)": util_ratio(dem_edge, tie_cap),
            "Tie (corner)": util_ratio(dem_corner, tie_cap),
            "Tie (top/bottom edge)": util_ratio(dem_tb, tie_cap),
        }

    seg_rows = []
    for _, r in profile.iterrows():
        depth_mid = float(r["DepthTop_ft"] + r["DepthBot_ft"]) * 0.5
        pu = ply_util_at(depth_mid)
        su = stud_util_at(depth_mid)
        wu = waler_util_at(depth_mid)
        tu = tie_utils_at(depth_mid)

        controls = {
            "Plywood": pu,
            "Stud": su,
            "Double waler": wu,
            **tu,
        }
        # controlling
        best = None
        maxu = -1.0
        for k, v in controls.items():
            if v is None or math.isnan(v):
                continue
            if v > maxu:
                maxu = v
                best = k

        seg_rows.append({
            **{k: r[k] for k in r.index},
            "ply_util": pu,
            "stud_util": su,
            "waler_util": wu,
            "tie_util_interior": tu["Tie (interior)"],
            "tie_util_edge": tu["Tie (edge)"],
            "tie_util_corner": tu["Tie (corner)"],
            "tie_util_tb_edge": tu["Tie (top/bottom edge)"],
            "controlling_member": best or "",
            "controlling_util": maxu if maxu >= 0 else float("nan"),
        })

    return pd.DataFrame(seg_rows)


# -----------------------------
# Report generation (CSV/PDF)
# -----------------------------
def build_pdf_bytes(report: Dict) -> bytes:
    buf = io.BytesIO()
    doc = SimpleDocTemplate(buf, pagesize=letter, leftMargin=0.7*inch, rightMargin=0.7*inch, topMargin=0.7*inch, bottomMargin=0.7*inch)
    styles = getSampleStyleSheet()
    story = []

    story.append(Paragraph("Wood Formwork Design Report", styles["Title"]))
    story.append(Spacer(1, 0.15*inch))

    meta = report.get("meta", {})
    story.append(Paragraph(f"Generated: {meta.get('generated_at','')}", styles["Normal"]))
    story.append(Spacer(1, 0.15*inch))

    # Inputs
    story.append(Paragraph("Inputs", styles["Heading2"]))
    inputs = report.get("inputs", {})
    input_rows = [["Field", "Value"]]
    for k, v in inputs.items():
        input_rows.append([str(k), str(v)])
    t = Table(input_rows, colWidths=[2.7*inch, 3.6*inch])
    t.setStyle(TableStyle([
        ("BACKGROUND", (0,0), (-1,0), colors.lightgrey),
        ("GRID", (0,0), (-1,-1), 0.25, colors.grey),
        ("VALIGN", (0,0), (-1,-1), "TOP"),
    ]))
    story.append(t)
    story.append(Spacer(1, 0.2*inch))

    # Pressure summary
    story.append(Paragraph("Pressure Summary", styles["Heading2"]))
    ps = report.get("pressure_summary", {})
    ps_rows = [["Item", "Value"]]
    for k, v in ps.items():
        ps_rows.append([str(k), str(v)])
    t2 = Table(ps_rows, colWidths=[2.7*inch, 3.6*inch])
    t2.setStyle(TableStyle([
        ("BACKGROUND", (0,0), (-1,0), colors.lightgrey),
        ("GRID", (0,0), (-1,-1), 0.25, colors.grey),
        ("VALIGN", (0,0), (-1,-1), "TOP"),
    ]))
    story.append(t2)
    story.append(Spacer(1, 0.2*inch))

    # Utilization summary
    story.append(Paragraph("Governing Utilizations", styles["Heading2"]))
    us = report.get("util_summary", {})
    us_rows = [["Member / Case", "Utilization (max)"]]
    for k, v in us.items():
        us_rows.append([str(k), f"{v:.3f}" if isinstance(v, (int,float)) and not math.isnan(v) else str(v)])
    t3 = Table(us_rows, colWidths=[3.2*inch, 3.1*inch])
    t3.setStyle(TableStyle([
        ("BACKGROUND", (0,0), (-1,0), colors.lightgrey),
        ("GRID", (0,0), (-1,-1), 0.25, colors.grey),
        ("VALIGN", (0,0), (-1,-1), "TOP"),
    ]))
    story.append(t3)
    story.append(Spacer(1, 0.2*inch))

    # Segment table (truncated for PDF if large)
    seg = report.get("segment_table", [])
    story.append(Paragraph("Segment Checks (top → bottom)", styles["Heading2"]))
    if seg:
        df = pd.DataFrame(seg)
        # select a compact subset of columns
        cols = ["Segment", "DepthTop_ft", "DepthBot_ft", "p_mid_psf", "controlling_member", "controlling_util"]
        df2 = df[cols].copy()
        if len(df2) > 60:
            df2 = pd.concat([df2.head(30), df2.tail(30)], ignore_index=True)
        tbl = [cols] + df2.round(3).astype(str).values.tolist()
        t4 = Table(tbl, colWidths=[0.7*inch, 0.9*inch, 0.9*inch, 0.9*inch, 2.2*inch, 0.9*inch])
        t4.setStyle(TableStyle([
            ("BACKGROUND", (0,0), (-1,0), colors.lightgrey),
            ("GRID", (0,0), (-1,-1), 0.25, colors.grey),
            ("VALIGN", (0,0), (-1,-1), "TOP"),
        ]))
        story.append(t4)
        if len(seg) > 60:
            story.append(Spacer(1, 0.08*inch))
            story.append(Paragraph("Note: Segment table truncated in PDF. Download CSV for full detail.", styles["Italic"]))
    else:
        story.append(Paragraph("No segment data available.", styles["Normal"]))

    doc.build(story)
    return buf.getvalue()


# -----------------------------
# Dash UI
# -----------------------------
app = Dash(__name__)
server = app.server

# -----------------------------
# Heartbeat monitor (auto-shutdown)
# - Configure timeout via environment variable HEARTBEAT_TIMEOUT_SECONDS (default 300s)
# - Each connected client emits a heartbeat every 5s using a client-side Interval
# -----------------------------
HEARTBEAT_TIMEOUT_SECONDS = int(os.getenv("HEARTBEAT_TIMEOUT_SECONDS", "300"))
HEARTBEAT_CHECK_INTERVAL = 1  # polling interval for monitor thread (s)
LAST_HEARTBEAT = dt.datetime.utcnow()


def _start_heartbeat_monitor(timeout: int = HEARTBEAT_TIMEOUT_SECONDS, check_interval: int = HEARTBEAT_CHECK_INTERVAL):
    """Background thread that shuts down the process when no heartbeat has been
    received for `timeout` seconds."""
    def monitor():
        while True:
            time.sleep(check_interval)
            lb = LAST_HEARTBEAT
            if lb is None:
                continue
            elapsed = (dt.datetime.utcnow() - lb).total_seconds()
            if elapsed > timeout:
                print(f"[heartbeat] no clients for {elapsed:.0f}s (> {timeout}s); shutting down.")
                try:
                    # Try a clean exit
                    os._exit(0)
                except Exception:
                    try:
                        import signal
                        os.kill(os.getpid(), signal.SIGTERM)
                    except Exception:
                        pass
    t = threading.Thread(target=monitor, daemon=True)
    t.start()

# start monitor immediately
_start_heartbeat_monitor()

app.index_string = """
<!DOCTYPE html>
<html>
    <head>
        {%metas%}
        <title>Formwork Design</title>
        {%favicon%}
        {%css%}
        <style>
            :root {
                --ink: #0b1220;
                --muted: #5a6675;
                --card: #ffffff;
                --border: #d6dee8;
                --accent: #0f1f2f;
                --accent-2: #0f766e;
                --accent-3: #f97316;
                --accent-soft: rgba(15,118,110,0.18);
                --shadow: 0 20px 40px rgba(15,23,42,0.12);
                --shadow-soft: 0 10px 22px rgba(15,23,42,0.08);
            }
            html, body {
                height: 100%;
            }
            body {
                margin: 0;
                color: var(--ink);
                font-family: "Aptos","Bahnschrift","Candara","Corbel","Segoe UI",sans-serif;
                background:
                    radial-gradient(900px 420px at 8% -10%, rgba(255,255,255,0.95), rgba(255,255,255,0)),
                    radial-gradient(760px 380px at 92% -5%, rgba(209,232,255,0.75), rgba(209,232,255,0)),
                    linear-gradient(180deg, #f4f7fb 0%, #eef2f6 52%, #f5efe7 100%),
                    repeating-linear-gradient(135deg, rgba(15,23,42,0.035) 0px, rgba(15,23,42,0.035) 1px, transparent 1px, transparent 14px);
            }
            .app-shell {
                max-width: 1280px;
                margin: 20px auto 60px;
                padding: 0 16px;
            }
            .app-hero {
                display: flex;
                align-items: stretch;
                justify-content: space-between;
                gap: 16px;
                padding: 18px;
                background: rgba(255,255,255,0.88);
                border: 1px solid rgba(15,23,42,0.08);
                border-radius: 22px;
                box-shadow: var(--shadow);
                margin-bottom: 16px;
                animation: heroIn 0.5s ease both;
            }
            .app-hero-text {
                flex: 1 1 60%;
            }
            .app-eyebrow {
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 2px;
                font-weight: 700;
                color: var(--muted);
            }
            .app-title {
                font-size: 32px;
                font-weight: 700;
                letter-spacing: 0.2px;
                margin: 6px 0 6px;
                font-family: "Bahnschrift","Aptos","Candara",sans-serif;
            }
            .app-subtitle {
                margin: 0;
                color: var(--muted);
                font-size: 14px;
                max-width: 760px;
            }
            .app-hero-panel {
                display: grid;
                grid-template-columns: repeat(3, minmax(0, 1fr));
                gap: 10px;
                align-self: center;
                min-width: 280px;
            }
            .hero-stat {
                padding: 10px 12px;
                border-radius: 14px;
                border: 1px solid rgba(15,23,42,0.08);
                background: rgba(15,23,42,0.04);
            }
            .hero-stat strong {
                display: block;
                font-size: 13px;
                letter-spacing: 0.2px;
            }
            .hero-stat span {
                display: block;
                font-size: 11px;
                color: var(--muted);
                margin-top: 2px;
            }
            .card {
                background: var(--card);
                border: 1px solid rgba(15,23,42,0.08);
                border-radius: 18px;
                padding: 16px 16px 10px;
                margin-bottom: 14px;
                box-shadow: var(--shadow-soft);
                animation: cardIn 0.45s ease both;
                animation-delay: var(--delay, 0ms);
            }
            .card h3 {
                margin: 0 0 12px;
                font-size: 15px;
                letter-spacing: 0.2px;
                font-weight: 700;
            }
            .card h4 {
                margin: 12px 0 8px;
                font-size: 13px;
                color: var(--ink);
            }
            .grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
                gap: 12px;
            }
            .grid-3 {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
            @media (max-width: 900px) {
                .grid-3 {
                    grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
                }
                .app-hero {
                    flex-direction: column;
                }
                .app-hero-panel {
                    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                }
            }
            .tabs-wrap {
                margin-top: 12px;
            }
            .tabs .tab {
                padding: 12px 16px;
                border-radius: 14px;
                border: 1px solid transparent;
                background: rgba(255,255,255,0.82);
                margin-right: 8px;
                transition: all 160ms ease;
            }
            .tabs .tab:hover {
                border-color: var(--border);
                transform: translateY(-1px);
            }
            .tabs .tab--selected {
                background: var(--accent);
                color: #ffffff;
                border-color: var(--accent);
                box-shadow: 0 8px 18px rgba(17,24,39,0.25);
            }
            .tab-body {
                padding: 10px 0 0;
            }
            input, select, textarea, .Select-control {
                border-radius: 10px;
                border: 1px solid #cbd5e1;
                background: #f9fbfd;
                padding: 8px 10px;
                box-shadow: none;
            }
            input:focus, select:focus, textarea:focus, .Select-control:hover {
                border-color: var(--accent-2);
                box-shadow: 0 0 0 3px var(--accent-soft);
                outline: none;
            }
            label {
                display: block;
                font-size: 12px;
                font-weight: 600;
                color: var(--muted);
                letter-spacing: 0.2px;
                margin-bottom: 4px;
            }
            .muted {
                color: var(--muted);
            }
            .field-help {
                font-size: 11px;
                color: var(--muted);
                margin-top: 6px;
            }
            button {
                background: var(--accent);
                color: #ffffff;
                border: none;
                padding: 10px 14px;
                border-radius: 10px;
                font-weight: 600;
                cursor: pointer;
                transition: all 160ms ease;
                box-shadow: 0 10px 18px rgba(15,23,42,0.18);
            }
            button:hover {
                transform: translateY(-1px);
                box-shadow: 0 12px 20px rgba(15,23,42,0.22);
            }
            button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
                box-shadow: none;
            }
            .diagram-panel {
                border-radius: 16px;
                border: 1px solid rgba(15,23,42,0.08);
                background: linear-gradient(180deg, rgba(255,255,255,0.92) 0%, rgba(248,250,252,0.92) 100%);
                padding: 8px;
            }
            .nds-summary-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 12px;
                margin-top: 10px;
            }
            .nds-summary-card {
                border-radius: 14px;
                border: 1px solid rgba(15,23,42,0.08);
                background: #f8fafc;
                padding: 10px 12px;
            }
            .nds-summary-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
                margin-bottom: 8px;
            }
            .nds-summary-title {
                font-weight: 700;
                font-size: 13px;
            }
            .nds-pill {
                font-size: 11px;
                background: rgba(15,118,110,0.12);
                color: #0f766e;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid rgba(15,118,110,0.22);
                white-space: nowrap;
            }
            .nds-table {
                width: 100%;
                border-collapse: collapse;
                font-size: 12px;
            }
            .nds-table th, .nds-table td {
                text-align: right;
                padding: 6px 8px;
                border-bottom: 1px solid rgba(15,23,42,0.08);
            }
            .nds-table th:first-child, .nds-table td:first-child {
                text-align: left;
            }
            .nds-table thead th {
                color: var(--muted);
                font-weight: 600;
                font-size: 11px;
                text-transform: uppercase;
                letter-spacing: 0.4px;
            }
            .nds-table tbody tr:last-child td {
                border-bottom: none;
            }
            .dash-table-container .dash-spreadsheet {
                border: 1px solid var(--border);
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 10px 20px rgba(15,23,42,0.08);
            }
            .dash-table-container .dash-header {
                background: #f1f5f9;
                font-weight: 600;
            }
            .dash-table-container .dash-cell {
                padding: 8px 10px;
            }
            @keyframes heroIn {
                from { opacity: 0; transform: translateY(-8px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes cardIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
        </style>
    </head>
    <body>
        {%app_entry%}
        <footer>
            {%config%}
            {%scripts%}
            {%renderer%}
        </footer>
    </body>
</html>
"""

def dropdown_options(d: Dict[str, Dict]) -> List[Dict[str, str]]:
    return [{"label": k, "value": k} for k in d.keys()]

app.layout = html.Div(
    className="app-shell",
    children=[
        html.Div(
            className="app-hero",
            children=[
                html.Div(
                    className="app-hero-text",
                    children=[
                        html.Div("Formwork design suite", className="app-eyebrow"),
                        html.H2("Wood Concrete Formwork Design", className="app-title"),
                        html.P(
                            "Segmented pressure checks, NDS-driven materials, and tie capacity verification in one view.",
                            className="app-subtitle",
                        ),
                    ],
                ),
                html.Div(
                    className="app-hero-panel",
                    children=[
                        html.Div(className="hero-stat", children=[
                            html.Strong("ACI 347R-14"),
                            html.Span("Lateral pressure model"),
                        ]),
                        html.Div(className="hero-stat", children=[
                            html.Strong("NDS 2018"),
                            html.Span("Reference design values"),
                        ]),
                        html.Div(className="hero-stat", children=[
                            html.Strong("ASD checks"),
                            html.Span("Plywood, studs, walers, ties"),
                        ]),
                    ],
                ),
            ],
        ),

        # Heartbeat components (hidden): each client will ping the server every 5s to indicate it's alive
        dcc.Interval(id='heartbeat-interval', interval=5_000, n_intervals=0),
        dcc.Store(id='heartbeat-store'),

        dcc.Tabs(
            className="tabs",
            parent_className="tabs-wrap",
            value="tab_inputs",
            children=[
                dcc.Tab(label="Inputs & Summary", value="tab_inputs", className="tab", selected_className="tab--selected", children=[
                    html.Div(className="tab-body", children=[
                        html.Div(className="card", style={"--delay":"0ms"}, children=[
                            html.H3("1) Fresh Concrete Lateral Pressure (ACI 347R-14)"),
                            html.Div(
                                style={"display":"grid","gridTemplateColumns":"repeat(5, 1fr)","gap":"10px"},
                                children=[
                                    html.Div([
                                        html.Label("Element type"),
                                        dcc.Dropdown(
                                            id="element_type",
                                            options=[{"label":"Wall","value":"wall"},{"label":"Column","value":"column"}],
                                            value="wall", clearable=False
                                        ),
                                    ]),
                                    html.Div([
                                        html.Label("Form height h (ft)"),
                                        dcc.Input(id="form_height_ft", type="number", value=12, min=0, step=0.5, style={"width":"100%"}),
                                    ]),
                                    html.Div([
                                        html.Label("Segment height (ft)"),
                                        dcc.Input(id="segment_ft", type="number", value=1.0, min=0.25, step=0.25, style={"width":"100%"}),
                                    ]),
                                    html.Div([
                                        html.Label("Unit weight w (pcf)"),
                                        dcc.Input(id="unit_weight_pcf", type="number", value=150, min=80, step=1, style={"width":"100%"}),
                                    ]),
                                    html.Div([
                                        html.Label("Temperature T (°F)"),
                                        dcc.Input(id="temp_F", type="number", value=70, min=10, step=1, style={"width":"100%"}),
                                    ]),

                                    html.Div([
                                        html.Label("Placement rate R (ft/hr)"),
                                        dcc.Input(id="rate_ftph", type="number", value=7, min=0, step=0.5, style={"width":"100%"}),
                                    ]),
                                    html.Div([
                                        html.Label("Slump (in)"),
                                        dcc.Input(id="slump_in", type="number", value=5, min=0, step=0.5, style={"width":"100%"}),
                                    ]),
                                    html.Div([
                                        html.Label("Internal vibration depth (ft)"),
                                        dcc.Input(id="vib_depth_ft", type="number", value=4, min=0, step=0.5, style={"width":"100%"}),
                                    ]),
                                    html.Div([
                                        html.Label("Mix category"),
                                        dcc.Dropdown(
                                            id="mix_category",
                                            options=[
                                                {"label":"Normal", "value":"normal"},
                                                {"label":"High cementitious (slower set)", "value":"high_cementitious"},
                                                {"label":"Retarded (explicit)", "value":"retarded"},
                                                {"label":"Accelerated", "value":"accelerated"},
                                            ],
                                            value="normal", clearable=False
                                        ),
                                    ]),
                                    html.Div([
                                        html.Label("Special conditions"),
                                        dcc.Checklist(
                                            id="special_conditions",
                                            options=[
                                                {"label":"Retarder included", "value":"retarder"},
                                                {"label":"SCC (hydrostatic)", "value":"scc"},
                                                {"label":"Pumped from base (+25%)", "value":"pumped"},
                                            ],
                                            value=[],
                                        ),
                                    ]),
                                ],
                            ),
                            html.Div(id="pressure_summary", style={"marginTop":"10px"})
                        ]),

                        html.Div(className="card", style={"--delay":"80ms"}, children=[
                            html.H3("2) Materials (NDS presets for studs/walers)"),
                            html.Div(style={"display":"grid","gridTemplateColumns":"repeat(6, 1fr)","gap":"10px"}, children=[
                                html.Div([
                                    html.Label("Use NDS presets for studs/walers"),
                                    dcc.Checklist(
                                        id="use_nds",
                                        options=[{"label":"Enabled", "value":"yes"}],
                                        value=["yes"],
                                    ),
                                ]),
                                html.Div([
                                    html.Label("Species"),
                                    dcc.Dropdown(
                                        id="nds_species",
                                        options=nds_species_options(),
                                        value=DEFAULT_NDS_SPECIES,
                                        clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label("Grade"),
                                    dcc.Dropdown(
                                        id="nds_grade",
                                        options=nds_grade_options_for_species(DEFAULT_NDS_SPECIES),
                                        value=DEFAULT_NDS_GRADE,
                                        clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label("CD (duration factor)"),
                                    dcc.Dropdown(
                                        id="nds_cd_preset",
                                        options=[
                                            {"label":"0.90", "value":0.9},
                                            {"label":"1.00", "value":1.0},
                                            {"label":"1.15", "value":1.15},
                                            {"label":"1.25", "value":1.25},
                                            {"label":"1.60", "value":1.6},
                                        ],
                                        value=1.25,
                                        clearable=False
                                    ),
                                    dcc.Input(
                                        id="nds_cd_custom",
                                        type="number",
                                        placeholder="Custom CD (override)",
                                        min=0.1,
                                        step=0.01,
                                        style={"width":"100%", "marginTop":"6px"},
                                    ),
                                    html.Div("Custom overrides preset if set.", className="field-help"),
                                ]),
                                html.Div([
                                    html.Label("Moisture content > 19%?"),
                                    dcc.Dropdown(
                                        id="nds_moisture",
                                        options=[{"label":"No", "value":"no"},{"label":"Yes", "value":"yes"}],
                                        value="no",
                                        clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label("Temperature > 100F?"),
                                    dcc.Dropdown(
                                        id="nds_temp",
                                        options=[{"label":"No", "value":"no"},{"label":"Yes", "value":"yes"}],
                                        value="no",
                                        clearable=False
                                    ),
                                ]),
                            ]),
                            html.Div(id="nds_summary", className="nds-summary-grid"),
                        ]),

                        html.Div(className="card", style={"--delay":"160ms"}, children=[
                            html.H3("3) Geometry + Member Allowables (ASD)"),
                            html.Div(style={"display":"grid","gridTemplateColumns":"repeat(6, 1fr)","gap":"10px"}, children=[
                                html.Div([
                                    html.Label("Plywood thickness (in)"),
                                    dcc.Dropdown(
                                        id="ply_thk",
                                        options=[{"label":x, "value":x} for x in [0.5, 0.625, 0.75, 0.875, 1.0, 1.125]],
                                        value=0.75, clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label("Stud size"),
                                    dcc.Dropdown(
                                        id="stud_size",
                                        options=[{"label":k, "value":k} for k in DIMLUMBER_OPTIONS],
                                        value="2x4", clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label("Stud orientation"),
                                    dcc.Dropdown(
                                        id="stud_orientation",
                                        options=[
                                            {"label":"Vertical studs (common)", "value":"vertical"},
                                            {"label":"Horizontal studs", "value":"horizontal"},
                                        ],
                                        value="vertical", clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label(id="stud_spacing_label"),
                                    dcc.Input(id="stud_spacing_in", type="number", value=16, min=1, step=1, style={"width":"100%"}),
                                ]),
                                html.Div([
                                    html.Label("Double waler size"),
                                    dcc.Dropdown(
                                        id="waler_size",
                                        options=[{"label":k, "value":k} for k in DIMLUMBER_OPTIONS],
                                        value="2x6", clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label(id="waler_spacing_label"),
                                    dcc.Input(id="waler_spacing_in", type="number", value=24, min=1, step=1, style={"width":"100%"}),
                                ]),
                                html.Div([
                                    html.Label("Tie spacing along waler (in)"),
                                    dcc.Input(id="tie_spacing_in", type="number", value=24, min=1, step=1, style={"width":"100%"}),
                                ]),
                                html.Div([
                                    html.Label("Tie type"),
                                    dcc.Dropdown(
                                        id="tie_type",
                                        options=[
                                            {"label":"Snap tie", "value":"snap_tie"},
                                            {"label":"Heavy duty snap tie", "value":"heavy_snap_tie"},
                                            {"label":"Taper tie (select size)", "value":"taper_tie"},
                                            {"label":"Coil rod (select diameter)", "value":"coil_rod"},
                                        ],
                                        value="snap_tie", clearable=False
                                    ),
                                ]),
                                html.Div([
                                    html.Label("Tie size (if applicable)"),
                                    dcc.Dropdown(id="tie_size", options=[], value=None, disabled=True, clearable=False),
                                ]),
                                html.Div([
                                    html.Label("Tie SWL override (lb, optional)"),
                                    dcc.Input(id="tie_swl_override", type="number", value=None, min=0, step=100, style={"width":"100%"}),
                                ]),
                                html.Div([
                                    html.Label("Deflection limit plywood (L/…)"),
                                    dcc.Input(id="defl_ply", type="number", value=240, min=60, step=10, style={"width":"100%"}),
                                ]),
                                html.Div([
                                    html.Label("Deflection limit studs (L/…)"),
                                    dcc.Input(id="defl_stud", type="number", value=240, min=60, step=10, style={"width":"100%"}),
                                ]),
                                html.Div([
                                    html.Label("Deflection limit walers (L/…)"),
                                    dcc.Input(id="defl_waler", type="number", value=240, min=60, step=10, style={"width":"100%"}),
                                ]),
                            ]),
                            html.H4("Plywood allowables (verify per your spec)"),
                            html.Div(style={"display":"grid","gridTemplateColumns":"repeat(3, 1fr)","gap":"10px"}, children=[
                                html.Div([html.Label("Plywood Fb (psi)"), dcc.Input(id="ply_Fb", type="number", value=1500, min=1, step=50, style={"width":"100%"})]),
                                html.Div([html.Label("Plywood Fv (psi)"), dcc.Input(id="ply_Fv", type="number", value=120, min=1, step=10, style={"width":"100%"})]),
                                html.Div([html.Label("Plywood E (psi)"),  dcc.Input(id="ply_E",  type="number", value=1_200_000, min=1, step=50_000, style={"width":"100%"})]),
                            ]),
                            html.H4("Stud allowables (psi)"),
                            html.Div(style={"display":"grid","gridTemplateColumns":"repeat(3, 1fr)","gap":"10px"}, children=[
                                html.Div([html.Label("Stud Fb"), dcc.Input(id="stud_Fb", type="number", value=900, min=1, step=25, style={"width":"100%"})]),
                                html.Div([html.Label("Stud Fv"), dcc.Input(id="stud_Fv", type="number", value=180, min=1, step=10, style={"width":"100%"})]),
                                html.Div([html.Label("Stud E"),  dcc.Input(id="stud_E",  type="number", value=1_600_000, min=1, step=50_000, style={"width":"100%"})]),
                            ]),
                            html.H4("Double waler allowables (psi)"),
                            html.Div(style={"display":"grid","gridTemplateColumns":"repeat(3, 1fr)","gap":"10px"}, children=[
                                html.Div([html.Label("Waler Fb"), dcc.Input(id="waler_Fb", type="number", value=900, min=1, step=25, style={"width":"100%"})]),
                                html.Div([html.Label("Waler Fv"), dcc.Input(id="waler_Fv", type="number", value=180, min=1, step=10, style={"width":"100%"})]),
                                html.Div([html.Label("Waler E"),  dcc.Input(id="waler_E",  type="number", value=1_600_000, min=1, step=50_000, style={"width":"100%"})]),
                            ]),
                            html.Div(id="tie_capacity_display", style={"marginTop":"10px"})
                        ]),

                        html.Div(className="card", style={"--delay":"240ms"}, children=[
                            html.H3("4) Formwork layout diagram"),
                            html.Div(className="field-help", children="Indicative formwork geometry with member sizes and spacings."),
                            html.Div(className="diagram-panel", children=[
                                dcc.Graph(
                                    id="formwork_diagram",
                                    figure=build_formwork_diagram_figure(
                                        "2x4",
                                        "2x6",
                                        16,
                                        24,
                                        24,
                                        "vertical",
                                        12,
                                    ),
                                    config={"displayModeBar": False, "responsive": True},
                                    style={"height":"360px"},
                                ),
                            ]),
                        ]),

                        html.Div(className="card", style={"--delay":"320ms"}, children=[
                            html.H3("5) Overall (conservative) Utilizations (uniform p = p_cap)"),
                            dash_table.DataTable(
                                id="util_table",
                                columns=[
                                    {"name":"Member", "id":"Member"},
                                    {"name":"Check", "id":"Check"},
                                    {"name":"Demand", "id":"Demand"},
                                    {"name":"Capacity", "id":"Capacity"},
                                    {"name":"Utilization", "id":"Utilization"},
                                    {"name":"Status", "id":"Status"},
                                ],
                                data=[],
                                style_table={"overflowX":"auto"},
                                style_cell={"fontSize":"12px","padding":"6px","whiteSpace":"normal","height":"auto"},
                                style_header={"fontWeight":"bold","backgroundColor":"#f5f5f5"},
                            ),
                        ]),
                    ])
                ]),

                dcc.Tab(label="Pressure Profile", value="tab_pressure", className="tab", selected_className="tab--selected", children=[
                    html.Div(className="tab-body", children=[
                        html.H3("Non-uniform Pressure Diagram (p vs depth)"),
                        dcc.Graph(id="pressure_graph"),
                        html.Div(style={"color":"#555"}, children=[
                            html.Div("Profile assumed: p(z) = min(w·z, p_cap)."),
                            html.Div("p_cap is the governing ACI max lateral pressure (including min pressure and hydrostatic cap)."),
                        ])
                    ])
                ]),

                dcc.Tab(label="Segment Checks", value="tab_segments", className="tab", selected_className="tab--selected", children=[
                    html.Div(className="tab-body", children=[
                        html.H3("Member-by-elevation critical checks (by segment midpoint)"),
                        dash_table.DataTable(
                            id="segment_table",
                            columns=[
                                {"name":"Seg", "id":"Segment"},
                                {"name":"DepthTop (ft)", "id":"DepthTop_ft"},
                                {"name":"DepthBot (ft)", "id":"DepthBot_ft"},
                                {"name":"p_mid (psf)", "id":"p_mid_psf"},
                                {"name":"Ply util", "id":"ply_util"},
                                {"name":"Stud util", "id":"stud_util"},
                                {"name":"Waler util", "id":"waler_util"},
                                {"name":"Tie util (int)", "id":"tie_util_interior"},
                                {"name":"Tie util (edge)", "id":"tie_util_edge"},
                                {"name":"Tie util (corner)", "id":"tie_util_corner"},
                                {"name":"Controlling", "id":"controlling_member"},
                                {"name":"Util", "id":"controlling_util"},
                            ],
                            data=[],
                            page_size=25,
                            style_table={"overflowX":"auto"},
                            style_cell={"fontSize":"12px","padding":"6px"},
                            style_header={"fontWeight":"bold","backgroundColor":"#f5f5f5"},
                        ),
                    ])
                ]),

                dcc.Tab(label="Report Export", value="tab_report", className="tab", selected_className="tab--selected", children=[
                    html.Div(className="tab-body", children=[
                        html.H3("Export calculation report"),
                        html.Div(style={"display":"flex","gap":"12px","alignItems":"center"}, children=[
                            html.Button("Download CSV (segment checks)", id="download_csv_btn"),
                            html.Button("Download PDF (summary)", id="download_pdf_btn"),
                            dcc.Download(id="download_csv"),
                            dcc.Download(id="download_pdf"),
                        ]),
                        html.Div(style={"marginTop":"10px","color":"#555"}, children=[
                            html.Div("CSV includes the full per-segment table."),
                            html.Div("PDF includes inputs, pressure summary, governing utilizations, and a truncated segment table if long."),
                        ])
                    ])
                ]),
            ]
        ),

        dcc.Store(id="calc_store"),
    ]
)


# -----------------------------
# Small UI callbacks
# -----------------------------
@app.callback(
    Output("tie_size", "options"),
    Output("tie_size", "value"),
    Output("tie_size", "disabled"),
    Input("tie_type", "value"),
)
def update_tie_size_options(tie_type: str):
    if tie_type == "taper_tie":
        opts = [{"label": f"{k} (SWL {v:,} lb)", "value": k} for k, v in TAPER_TIE_SWL_LB.items()]
        return opts, list(TAPER_TIE_SWL_LB.keys())[0], False
    if tie_type == "coil_rod":
        opts = [{"label": f"{k} (SWL {v:,} lb)", "value": k} for k, v in COIL_ROD_SWL_LB.items()]
        return opts, '1/2"', False
    return [], None, True


@app.callback(
    Output("stud_spacing_label", "children"),
    Output("waler_spacing_label", "children"),
    Input("stud_orientation", "value"),
)
def update_spacing_labels(stud_orientation: str):
    if stud_orientation == "horizontal":
        return "Stud spacing (vertical, in)", "Waler spacing (horizontal, in)"
    return "Stud spacing (horizontal, in)", "Waler spacing (vertical, in)"


# Formwork diagram updates
@app.callback(
    Output("formwork_diagram", "figure"),
    Input("stud_size", "value"),
    Input("waler_size", "value"),
    Input("stud_spacing_in", "value"),
    Input("waler_spacing_in", "value"),
    Input("tie_spacing_in", "value"),
    Input("stud_orientation", "value"),
    Input("form_height_ft", "value"),
)
def update_formwork_diagram(stud_size, waler_size, stud_spacing_in, waler_spacing_in, tie_spacing_in, stud_orientation, form_height_ft):
    return build_formwork_diagram_figure(
        stud_size or "2x4",
        waler_size or "2x6",
        stud_spacing_in,
        waler_spacing_in,
        tie_spacing_in,
        stud_orientation or "vertical",
        form_height_ft,
    )


# NDS preset -> auto-fill stud/waler allowables
@app.callback(
    Output("stud_Fb", "value"),
    Output("stud_Fv", "value"),
    Output("stud_E", "value"),
    Output("waler_Fb", "value"),
    Output("waler_Fv", "value"),
    Output("waler_E", "value"),
    Output("nds_summary", "children"),
    Input("use_nds", "value"),
    Input("nds_species", "value"),
    Input("nds_grade", "value"),
    Input("stud_size", "value"),
    Input("waler_size", "value"),
    Input("nds_cd_preset", "value"),
    Input("nds_cd_custom", "value"),
    Input("nds_moisture", "value"),
    Input("nds_temp", "value"),
    State("stud_Fb", "value"),
    State("stud_Fv", "value"),
    State("stud_E", "value"),
    State("waler_Fb", "value"),
    State("waler_Fv", "value"),
    State("waler_E", "value"),
)
def apply_nds_to_inputs(use_nds, species, grade, stud_size, waler_size, cd_preset, cd_custom, moisture, temp, sFb, sFv, sE, wFb, wFv, wE):
    enabled = (use_nds or []) and ("yes" in use_nds)
    if not enabled:
        txt = html.Div("NDS lookup disabled: using manual stud/waler allowables.", className="muted")
        return sFb, sFv, sE, wFb, wFv, wE, txt

    species = species or ""
    grade = grade or ""
    stud_size = stud_size or ""
    waler_size = waler_size or ""

    base_s = nds_lookup_reference(species, grade)
    base_w = nds_lookup_reference(species, grade)
    if base_s is None or base_w is None:
        txt = html.Div(
            "NDS lookup failed for the selected species/grade/size (or CSV missing): using manual stud/waler allowables.",
            className="muted",
        )
        return sFb, sFv, sE, wFb, wFv, wE, txt

    CD, cd_source = resolve_cd_value(cd_preset, cd_custom)
    is_wet = (moisture or "").lower() == "yes"
    is_hot = (temp or "").lower() == "yes"
    CM = nds_cm_factor(is_wet)
    Ct = nds_ct_factor(is_hot)
    Cf_s = nds_size_factor(species, grade, stud_size)
    Cf_w = nds_size_factor(species, grade, waler_size)
    adj_s = apply_nds_factors(base_s, CD, CM, Ct, Cf_s)
    adj_w = apply_nds_factors(base_w, CD, CM, Ct, Cf_w)

    stud_label = f"Stud {format_dim_label(stud_size)}"
    waler_label = f"Waler {format_dim_label(waler_size)}"
    summary_cards = [
        build_nds_summary_card("Stud adjustments", stud_label, base_s, adj_s, CD, CM, Ct, Cf_s, cd_source),
        build_nds_summary_card("Waler adjustments", waler_label, base_w, adj_w, CD, CM, Ct, Cf_w, cd_source),
    ]
    return adj_s["Fb"], adj_s["Fv"], adj_s["E"], adj_w["Fb"], adj_w["Fv"], adj_w["E"], summary_cards


@app.callback(
    Output("nds_grade", "options"),
    Output("nds_grade", "value"),
    Input("nds_species", "value"),
    State("nds_grade", "value"),
)
def update_nds_grade_options(species, current):
    opts = nds_grade_options_for_species(species or "")
    vals = [o["value"] for o in opts]
    val = current if current in vals else (vals[0] if vals else "")
    return opts, val



# -----------------------------
# Main calculation callback
# -----------------------------
@app.callback(
    Output("pressure_summary", "children"),
    Output("util_table", "data"),
    Output("tie_capacity_display", "children"),
    Output("pressure_graph", "figure"),
    Output("segment_table", "data"),
    Output("calc_store", "data"),
    Input("element_type", "value"),
    Input("form_height_ft", "value"),
    Input("segment_ft", "value"),
    Input("unit_weight_pcf", "value"),
    Input("temp_F", "value"),
    Input("rate_ftph", "value"),
    Input("slump_in", "value"),
    Input("vib_depth_ft", "value"),
    Input("mix_category", "value"),
    Input("special_conditions", "value"),
    Input("ply_thk", "value"),
    Input("stud_size", "value"),
    Input("waler_size", "value"),
    Input("stud_spacing_in", "value"),
    Input("waler_spacing_in", "value"),
    Input("tie_spacing_in", "value"),
    Input("stud_orientation", "value"),
    Input("ply_Fb", "value"),
    Input("ply_Fv", "value"),
    Input("ply_E", "value"),
    Input("stud_Fb", "value"),
    Input("stud_Fv", "value"),
    Input("stud_E", "value"),
    Input("waler_Fb", "value"),
    Input("waler_Fv", "value"),
    Input("waler_E", "value"),
    Input("defl_ply", "value"),
    Input("defl_stud", "value"),
    Input("defl_waler", "value"),
    Input("tie_type", "value"),
    Input("tie_size", "value"),
    Input("tie_swl_override", "value"),
)
def run_calcs(
    element_type, form_height_ft, segment_ft, unit_weight_pcf, temp_F, rate_ftph, slump_in, vib_depth_ft,
    mix_category, special_conditions,
    ply_thk, stud_size, waler_size, stud_spacing_in, waler_spacing_in, tie_spacing_in, stud_orientation,
    ply_Fb, ply_Fv, ply_E, stud_Fb, stud_Fv, stud_E, waler_Fb, waler_Fv, waler_E,
    defl_ply, defl_stud, defl_waler,
    tie_type, tie_size, tie_swl_override,
):
    # Parse special conditions
    sc = set(special_conditions or [])
    retarder = ("retarder" in sc)
    is_scc = ("scc" in sc)
    pumped = ("pumped" in sc)

    # Pressure
    pres = aci347r14_lateral_pressure_psf(
        element_type=element_type or "wall",
        height_ft=safe_float(form_height_ft, 0.0),
        w_pcf=safe_float(unit_weight_pcf, 150.0),
        T_F=safe_float(temp_F, 70.0),
        R_ftph=safe_float(rate_ftph, 0.0),
        slump_in=safe_float(slump_in, 5.0),
        internal_vib_depth_ft=safe_float(vib_depth_ft, 4.0),
        mix_category=mix_category or "normal",
        retarder_included=retarder,
        is_scc=is_scc,
        pumped_from_base=pumped,
    )
    p_cap = float(pres["p_cap_psf"])
    p_hydro = float(pres["p_hydro_psf"])
    p_emp = float(pres.get("p_empirical_psf", float("nan")))
    p_min = float(pres.get("p_min_psf", float("nan")))
    Cc = float(pres["Cc"])
    Cw = float(pres["Cw"])
    eq = str(pres["controlling_eq"])

    # Profile
    H = safe_float(form_height_ft, 0.0)
    seg = safe_float(segment_ft, 1.0)
    w = safe_float(unit_weight_pcf, 150.0)
    profile = build_pressure_profile(H, w, p_cap, seg)

    # Tie capacity
    swl = tie_swl_lb(tie_type or "snap_tie", tie_size)
    if tie_swl_override is not None and safe_float(tie_swl_override, float("nan")) > 0:
        swl = safe_float(tie_swl_override, swl)
        tie_note = "(override)"
    else:
        tie_note = "(preset)"
    tie_disp = html.Div([
        html.Strong("Tie capacity (SWL): "),
        f"{swl:,.0f} lb {tie_note}",
        html.Div("Tie checks shown for interior, edge, corner, and top/bottom-edge tributary reductions."),
    ])

    # Overall (uniform) util table at p_cap
    utils_uniform = compute_member_utils_uniform(
        p_psf=p_cap,
        plywood_t_in=safe_float(ply_thk, 0.75),
        stud_size=stud_size or "2x4",
        waler_size=waler_size or "2x6",
        stud_spacing_in=safe_float(stud_spacing_in, 16),
        waler_spacing_in=safe_float(waler_spacing_in, 24),
        tie_spacing_in=safe_float(tie_spacing_in, 24),
        ply_Fb=safe_float(ply_Fb, 1500),
        ply_Fv=safe_float(ply_Fv, 120),
        ply_E=safe_float(ply_E, 1_200_000),
        stud_Fb=safe_float(stud_Fb, 900),
        stud_Fv=safe_float(stud_Fv, 180),
        stud_E=safe_float(stud_E, 1_600_000),
        waler_Fb=safe_float(waler_Fb, 900),
        waler_Fv=safe_float(waler_Fv, 180),
        waler_E=safe_float(waler_E, 1_600_000),
        stud_orientation=stud_orientation or "vertical",
        defl_ratio_ply=safe_float(defl_ply, 240),
        defl_ratio_stud=safe_float(defl_stud, 240),
        defl_ratio_waler=safe_float(defl_waler, 240),
    )

    # Add tie utilizations at the governing pressure (interior/edge/corner/top-bottom)
    s_waler_ft = in_to_ft(max(safe_float(waler_spacing_in, 24), 0.0))
    s_tie_ft = in_to_ft(max(safe_float(tie_spacing_in, 24), 0.0))
    tie_area_int = s_waler_ft * s_tie_ft
    tie_cases = {
        "Tie (interior)": 1.00,
        "Tie (edge)": 0.50,
        "Tie (corner)": 0.25,
        "Tie (top/bottom edge)": 0.50,  # vertical tributary halved
    }
    for name, factor in tie_cases.items():
        demand = p_cap * tie_area_int * factor
        utils_uniform.append(MemberUtil(member="Tie", check=f"{name} (T ≤ SWL)", demand=demand, capacity=swl, util=util_ratio(demand, swl), units="lb"))

    # Render uniform utilization rows
    def fmt(x, nd=3):
        if x is None or math.isnan(float(x)):
            return "—"
        return f"{float(x):.{nd}f}"

    rows = []
    for u in utils_uniform:
        rows.append({
            "Member": u.member,
            "Check": u.check,
            "Demand": f"{fmt(u.demand)} {u.units}",
            "Capacity": f"{fmt(u.capacity)} {u.units}",
            "Utilization": fmt(u.util, 2),
            "Status": "OK" if (not math.isnan(u.util) and u.util <= 1.0) else "NG",
        })

    # Segment checks
    seg_df = compute_segment_checks(
        profile=profile,
        height_ft=H,
        w_pcf=w,
        p_cap_psf=p_cap,
        plywood_t_in=safe_float(ply_thk, 0.75),
        stud_size=stud_size or "2x4",
        waler_size=waler_size or "2x6",
        stud_spacing_in=safe_float(stud_spacing_in, 16),
        waler_spacing_in=safe_float(waler_spacing_in, 24),
        tie_spacing_in=safe_float(tie_spacing_in, 24),
        ply_Fb=safe_float(ply_Fb, 1500),
        ply_Fv=safe_float(ply_Fv, 120),
        ply_E=safe_float(ply_E, 1_200_000),
        stud_Fb=safe_float(stud_Fb, 900),
        stud_Fv=safe_float(stud_Fv, 180),
        stud_E=safe_float(stud_E, 1_600_000),
        waler_Fb=safe_float(waler_Fb, 900),
        waler_Fv=safe_float(waler_Fv, 180),
        waler_E=safe_float(waler_E, 1_600_000),
        stud_orientation=stud_orientation or "vertical",
        defl_ratio_ply=safe_float(defl_ply, 240),
        defl_ratio_stud=safe_float(defl_stud, 240),
        defl_ratio_waler=safe_float(defl_waler, 240),
        tie_type=tie_type or "snap_tie",
        tie_size=tie_size,
    )

    # Pressure graph
    # Plot p vs depth (top=0 to bottom=H)
    depths = np.concatenate([[0.0], seg_df["DepthBot_ft"].values])
    p_vals = np.array([pressure_at_depth_psf(z, w, p_cap) for z in depths])
    fig = {
        "data": [{
            "x": p_vals,
            "y": depths,
            "mode": "lines+markers",
            "name": "p(z)",
        }],
        "layout": {
            "title": "Pressure vs Depth (from top of placement)",
            "xaxis": {"title": "Pressure p (psf)"},
            "yaxis": {"title": "Depth z (ft)", "autorange": "reversed"},
            "margin": {"l": 60, "r": 20, "t": 50, "b": 50},
        }
    }

    # Segment table output
    seg_out = seg_df.copy()
    # Round for display
    for c in ["DepthTop_ft","DepthBot_ft","p_mid_psf","ply_util","stud_util","waler_util","tie_util_interior","tie_util_edge","tie_util_corner","controlling_util"]:
        seg_out[c] = seg_out[c].astype(float).round(3)
    seg_data = seg_out.to_dict("records")

    # Pressure summary display
    summary = html.Div([
        html.Div([html.Strong("p_cap (design max): "), f"{p_cap:,.0f} psf"]),
        html.Div([html.Strong("Hydrostatic at base: "), f"{p_hydro:,.0f} psf"]),
        html.Div([html.Strong("Empirical max (if used): "), ("—" if math.isnan(p_emp) else f"{p_emp:,.0f} psf")]),
        html.Div([html.Strong("Minimum (if used): "), ("—" if math.isnan(p_min) else f"{p_min:,.0f} psf")]),
        html.Div([html.Strong("Coefficients: "), f"Cc={Cc:.2f}, Cw={Cw:.2f}"]),
        html.Div([html.Strong("Controlling case: "), eq]),
    ])

    # Calc store (for exports)
    util_summary = {
        "Plywood (max seg)": float(np.nanmax(seg_df["ply_util"].values)),
        "Stud (max seg)": float(np.nanmax(seg_df["stud_util"].values)),
        "Double waler (max seg)": float(np.nanmax(seg_df["waler_util"].values)),
        "Tie (interior max seg)": float(np.nanmax(seg_df["tie_util_interior"].values)),
        "Tie (edge max seg)": float(np.nanmax(seg_df["tie_util_edge"].values)),
        "Tie (corner max seg)": float(np.nanmax(seg_df["tie_util_corner"].values)),
        "Tie (top/bottom edge max seg)": float(np.nanmax(seg_df["tie_util_tb_edge"].values)),
    }

    store = {
        "meta": {"generated_at": dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")},
        "inputs": {
            "element_type": element_type,
            "height_ft": H,
            "segment_ft": seg,
            "unit_weight_pcf": w,
            "temp_F": temp_F,
            "rate_ftph": rate_ftph,
            "slump_in": slump_in,
            "vib_depth_ft": vib_depth_ft,
            "mix_category": mix_category,
            "special_conditions": list(sc),
            "ply_thk_in": ply_thk,
            "stud_size": stud_size,
            "waler_size": waler_size,
            "stud_orientation": stud_orientation,
            "stud_spacing_in": stud_spacing_in,
            "waler_spacing_in": waler_spacing_in,
            "tie_spacing_in": tie_spacing_in,
            "tie_type": tie_type,
            "tie_size": tie_size,
            "tie_swl_lb": swl,
        },
        "pressure_summary": {
            "p_cap_psf": p_cap,
            "p_hydro_psf": p_hydro,
            "p_empirical_psf": None if math.isnan(p_emp) else p_emp,
            "p_min_psf": None if math.isnan(p_min) else p_min,
            "Cc": Cc,
            "Cw": Cw,
            "case": eq,
        },
        "util_summary": util_summary,
        "segment_table": seg_df.to_dict("records"),
    }

    return summary, rows, tie_disp, fig, seg_data, store


# -----------------------------
# Download callbacks
# -----------------------------
@app.callback(Output('heartbeat-store','data'), Input('heartbeat-interval','n_intervals'))
def _heartbeat(n_intervals):
    """Update the server-side LAST_HEARTBEAT whenever a client interval fires.
    The heartbeat value is returned into `heartbeat-store` so the client has a record
    (not otherwise used by the app)."""
    global LAST_HEARTBEAT
    LAST_HEARTBEAT = dt.datetime.utcnow()
    return {"last": LAST_HEARTBEAT.isoformat()}


@app.callback(
    Output("download_csv", "data"),
    Input("download_csv_btn", "n_clicks"),
    State("calc_store", "data"),
    prevent_initial_call=True,
)
def download_csv(n_clicks, store):
    if not store:
        return None
    df = pd.DataFrame(store.get("segment_table", []))
    if df.empty:
        df = pd.DataFrame([{"message":"No data"}])
    csv_bytes = df.to_csv(index=False).encode("utf-8")
    fname = f"formwork_segment_checks_{dt.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    return dcc.send_bytes(lambda b: b.write(csv_bytes), filename=fname)


@app.callback(
    Output("download_pdf", "data"),
    Input("download_pdf_btn", "n_clicks"),
    State("calc_store", "data"),
    prevent_initial_call=True,
)
def download_pdf(n_clicks, store):
    if not store:
        return None
    pdf_bytes = build_pdf_bytes(store)
    fname = f"formwork_report_{dt.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    return dcc.send_bytes(lambda b: b.write(pdf_bytes), filename=fname)


if __name__ == "__main__":
    app.run(debug=True, port=8051)
